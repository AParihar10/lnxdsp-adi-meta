From 58f218d1b4b1e645e493f66abe758d2990dbd3f3 Mon Sep 17 00:00:00 2001
From: Nathan Barrett Morrison <nathan.morrison@timesys.com>
Date: Mon, 13 May 2019 15:10:05 -0400
Subject: [PATCH] Add in Blackfin Hardware CRC crypto driver

---
 arch/arm/boot/dts/sc57x.dtsi           | 16 +++++++
 arch/arm/boot/dts/sc58x.dtsi           | 16 +++++++
 arch/arm/configs/sc573-ezkit_defconfig |  4 ++
 arch/arm/configs/sc584-ezkit_defconfig |  5 +-
 arch/arm/configs/sc589-ezkit_defconfig |  3 ++
 arch/arm/configs/sc589-mini_defconfig  |  3 ++
 drivers/crypto/Kconfig                 |  2 +-
 drivers/crypto/bfin_crc.c              | 86 +++++++++++++++++++++++++++-------
 drivers/crypto/bfin_crc.h              |  1 +
 9 files changed, 117 insertions(+), 19 deletions(-)

diff --git a/arch/arm/boot/dts/sc57x.dtsi b/arch/arm/boot/dts/sc57x.dtsi
index e473993bfbac..d904d4b10f64 100644
--- a/arch/arm/boot/dts/sc57x.dtsi
+++ b/arch/arm/boot/dts/sc57x.dtsi
@@ -202,6 +202,22 @@
 			interrupt-parent = <&gic>;
 			interrupts = <0 75 0>;
 		};
+		
+		crc0: crc@0x310A5000 {
+			compatible = "adi,hmac-crc";
+			reg = <0x310A5000 0xFF>;
+			interrupts = <0 154 0>;
+			dma_channel = <8>;
+			crypto_crc_poly = <0x5c5c5c5c>;
+		};
+
+		crc1: crc@0x310A6000 {
+			compatible = "adi,hmac-crc";
+			reg = <0x310A6000 0xFF>;
+			interrupts = <0 155 0>;
+			dma_channel = <18>;
+			crypto_crc_poly = <0x5c5c5c5c>;
+		};
 
 		watchdog@0x31008000 {
 			compatible = "arm,adi-watchdog";
diff --git a/arch/arm/boot/dts/sc58x.dtsi b/arch/arm/boot/dts/sc58x.dtsi
index 9ef56d7fb29e..31f19e8e9d51 100644
--- a/arch/arm/boot/dts/sc58x.dtsi
+++ b/arch/arm/boot/dts/sc58x.dtsi
@@ -232,6 +232,22 @@
 			dma-channel = <10>, <11>;
 			status = "disabled";
 		};
+		
+		crc0: crc@0x31001200 {
+			compatible = "adi,hmac-crc";
+			reg = <0x31001200 0xFF>;
+			interrupts = <0 176 0>;
+			dma_channel = <8>;
+			crypto_crc_poly = <0x5c5c5c5c>;
+		};
+
+		crc1: crc@0x31001300 {
+			compatible = "adi,hmac-crc";
+			reg = <0x31001300 0xFF>;
+			interrupts = <0 177 0>;
+			dma_channel = <18>;
+			crypto_crc_poly = <0x5c5c5c5c>;
+		};
 
 		watchdog@0x31008000 {
 			compatible = "arm,adi-watchdog";
diff --git a/arch/arm/configs/sc573-ezkit_defconfig b/arch/arm/configs/sc573-ezkit_defconfig
index e26fa4608fd3..ffbcc7fce2dd 100644
--- a/arch/arm/configs/sc573-ezkit_defconfig
+++ b/arch/arm/configs/sc573-ezkit_defconfig
@@ -133,4 +133,8 @@ CONFIG_DEBUG_PAGEALLOC=y
 # CONFIG_FTRACE is not set
 CONFIG_DEBUG_LL=y
 CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DEV_BFIN_CRC=y
 CONFIG_CRC_CCITT=y
diff --git a/arch/arm/configs/sc584-ezkit_defconfig b/arch/arm/configs/sc584-ezkit_defconfig
index 2983dbd3d6b8..40b2f433bc86 100644
--- a/arch/arm/configs/sc584-ezkit_defconfig
+++ b/arch/arm/configs/sc584-ezkit_defconfig
@@ -134,7 +134,8 @@ CONFIG_DEBUG_PAGEALLOC=y
 # CONFIG_FTRACE is not set
 CONFIG_DEBUG_LL=y
 CONFIG_EARLY_PRINTK=y
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_HMAC=y
 CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DEV_BFIN_CRC=y
 CONFIG_CRC_CCITT=y
diff --git a/arch/arm/configs/sc589-ezkit_defconfig b/arch/arm/configs/sc589-ezkit_defconfig
index 7db20c820c9a..d0cc7c52a350 100644
--- a/arch/arm/configs/sc589-ezkit_defconfig
+++ b/arch/arm/configs/sc589-ezkit_defconfig
@@ -147,5 +147,8 @@ CONFIG_DEBUG_PAGEALLOC=y
 # CONFIG_FTRACE is not set
 CONFIG_DEBUG_LL=y
 CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_HMAC=y
 CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DEV_BFIN_CRC=y
 CONFIG_CRC_CCITT=y
diff --git a/arch/arm/configs/sc589-mini_defconfig b/arch/arm/configs/sc589-mini_defconfig
index b95d11410b1d..66084aa8ef48 100644
--- a/arch/arm/configs/sc589-mini_defconfig
+++ b/arch/arm/configs/sc589-mini_defconfig
@@ -123,5 +123,8 @@ CONFIG_DEBUG_PAGEALLOC=y
 # CONFIG_FTRACE is not set
 CONFIG_DEBUG_LL=y
 CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_HMAC=y
 CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DEV_BFIN_CRC=y
 CONFIG_CRC_CCITT=y
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 4b741b83e23f..621c17fa2544 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -466,7 +466,7 @@ endif # if CRYPTO_DEV_UX500
 
 config CRYPTO_DEV_BFIN_CRC
 	tristate "Support for Blackfin CRC hardware"
-	depends on BF60x
+	depends on BF60x || ARCH_SC58X || ARCH_SC57X
 	help
 	  Newer Blackfin processors have CRC hardware. Select this if you
 	  want to use the Blackfin CRC module.
diff --git a/drivers/crypto/bfin_crc.c b/drivers/crypto/bfin_crc.c
index bfbf8bf77f03..de592dc28526 100644
--- a/drivers/crypto/bfin_crc.c
+++ b/drivers/crypto/bfin_crc.c
@@ -23,14 +23,23 @@
 #include <linux/delay.h>
 #include <linux/crypto.h>
 #include <linux/cryptohash.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
 #include <crypto/scatterwalk.h>
 #include <crypto/algapi.h>
 #include <crypto/hash.h>
 #include <crypto/internal/hash.h>
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_ARCH_HEADER_IN_MACH
+#include <mach/portmux.h>
+#include <mach/dma.h>
+#else
 #include <asm/dma.h>
 #include <asm/portmux.h>
+#endif
+
 #include <asm/io.h>
 
 #include "bfin_crc.h"
@@ -96,6 +105,26 @@ struct bfin_crypto_crc_ctx {
 	u32			key;
 };
 
+
+/*
+ * derive number of elements in scatterlist
+ */
+static int sg_count(struct scatterlist *sg_list)
+{
+	struct scatterlist *sg = sg_list;
+	int sg_nents = 1;
+
+	if (sg_list == NULL)
+		return 0;
+
+	while (!sg_is_last(sg)) {
+		sg_nents++;
+		sg = sg_next(sg);
+	}
+
+	return sg_nents;
+}
+
 /*
  * get element in scatter list by given index
  */
@@ -140,7 +169,7 @@ static int bfin_crypto_crc_init(struct ahash_request *req)
 	}
 	spin_unlock_bh(&crc_list.lock);
 
-	if (sg_nents(req->src) > CRC_MAX_DMA_DESC) {
+	if (sg_count(req->src) > CRC_MAX_DMA_DESC) {
 		dev_dbg(ctx->crc->dev, "init: requested sg list is too big > %d\n",
 			CRC_MAX_DMA_DESC);
 		return -EINVAL;
@@ -203,7 +232,7 @@ static void bfin_crypto_crc_config_dma(struct bfin_crypto_crc *crc)
 			crc->sg_cpu[i].x_count = 1;
 			crc->sg_cpu[i].x_modify = CHKSUM_DIGEST_SIZE;
 			dev_dbg(crc->dev, "%d: crc_dma: start_addr:0x%lx, "
-				"cfg:0x%x, x_count:0x%x, x_modify:0x%x\n",
+				"cfg:0x%lx, x_count:0x%lx, x_modify:0x%lx\n",
 				i, crc->sg_cpu[i].start_addr,
 				crc->sg_cpu[i].cfg, crc->sg_cpu[i].x_count,
 				crc->sg_cpu[i].x_modify);
@@ -233,7 +262,7 @@ static void bfin_crypto_crc_config_dma(struct bfin_crypto_crc *crc)
 		crc->sg_cpu[i].x_count = dma_count;
 		crc->sg_cpu[i].x_modify = dma_mod;
 		dev_dbg(crc->dev, "%d: crc_dma: start_addr:0x%lx, "
-			"cfg:0x%x, x_count:0x%x, x_modify:0x%x\n",
+			"cfg:0x%lx, x_count:0x%lx, x_modify:0x%lx\n",
 			i, crc->sg_cpu[i].start_addr,
 			crc->sg_cpu[i].cfg, crc->sg_cpu[i].x_count,
 			crc->sg_cpu[i].x_modify);
@@ -257,7 +286,7 @@ static void bfin_crypto_crc_config_dma(struct bfin_crypto_crc *crc)
 		crc->sg_cpu[i].x_count = 1;
 		crc->sg_cpu[i].x_modify = CHKSUM_DIGEST_SIZE;
 		dev_dbg(crc->dev, "%d: crc_dma: start_addr:0x%lx, "
-			"cfg:0x%x, x_count:0x%x, x_modify:0x%x\n",
+			"cfg:0x%lx, x_count:0x%lx, x_modify:0x%lx\n",
 			i, crc->sg_cpu[i].start_addr,
 			crc->sg_cpu[i].cfg, crc->sg_cpu[i].x_count,
 			crc->sg_cpu[i].x_modify);
@@ -350,14 +379,14 @@ static int bfin_crypto_crc_handle_queue(struct bfin_crypto_crc *crc,
 			sg_init_table(ctx->bufsl, nsg);
 			sg_set_buf(ctx->bufsl, ctx->buflast, ctx->buflast_len);
 			if (nsg > 1)
-				sg_chain(ctx->bufsl, nsg, req->src);
+				sg_chain(ctx->bufsl, nsg,
+						req->src);
 			ctx->sg = ctx->bufsl;
 		} else
 			ctx->sg = req->src;
 
 		/* Chop crc buffer size to multiple of 32 bit */
-		nsg = sg_nents(ctx->sg);
-		ctx->sg_nents = nsg;
+		nsg = ctx->sg_nents = sg_count(ctx->sg);
 		ctx->sg_buflen = ctx->buflast_len + req->nbytes;
 		ctx->bufnext_len = ctx->sg_buflen % 4;
 		ctx->sg_buflen &= ~0x3;
@@ -489,13 +518,13 @@ static struct ahash_alg algs = {
 	.digest		= bfin_crypto_crc_digest,
 	.setkey		= bfin_crypto_crc_setkey,
 	.halg.digestsize	= CHKSUM_DIGEST_SIZE,
+	.halg.statesize     = sizeof(struct bfin_crypto_crc_reqctx),
 	.halg.base	= {
 		.cra_name		= "hmac(crc32)",
 		.cra_driver_name	= DRIVER_NAME,
 		.cra_priority		= 100,
 		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
-						CRYPTO_ALG_ASYNC |
-						CRYPTO_ALG_OPTIONAL_KEY,
+						CRYPTO_ALG_ASYNC,
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(struct bfin_crypto_crc_ctx),
 		.cra_alignmask		= 3,
@@ -563,6 +592,16 @@ static int bfin_crypto_crc_suspend(struct platform_device *pdev, pm_message_t st
 
 #define bfin_crypto_crc_resume NULL
 
+#ifdef CONFIG_OF
+static const struct of_device_id bfin_crypto_of_match[] = {
+	{
+		.compatible = "adi,hmac-crc",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, bfin_crypto_of_match);
+#endif
+
 /**
  *	bfin_crypto_crc_probe - Initialize module
  *
@@ -572,6 +611,8 @@ static int bfin_crypto_crc_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct resource *res;
 	struct bfin_crypto_crc *crc;
+	const struct of_device_id *match;
+	struct device_node *node = pdev->dev.of_node;
 	unsigned int timeout = 100000;
 	int ret;
 
@@ -589,6 +630,11 @@ static int bfin_crypto_crc_probe(struct platform_device *pdev)
 	crypto_init_queue(&crc->queue, CRC_CCRYPTO_QUEUE_LENGTH);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
+		return -ENOENT;
+	}
+
 	crc->regs = devm_ioremap_resource(dev, res);
 	if (IS_ERR((void *)crc->regs)) {
 		dev_err(&pdev->dev, "Cannot map CRC IO\n");
@@ -608,12 +654,20 @@ static int bfin_crypto_crc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (res == NULL) {
-		dev_err(&pdev->dev, "No CRC DMA channel specified\n");
-		return -ENOENT;
+	match = of_match_device(of_match_ptr(bfin_crypto_of_match), &pdev->dev);
+	if (match) {
+		if (of_property_read_u32(node, "dma_channel", &crc->dma_ch))
+			return -ENOENT;
+		of_property_read_u32(node, "crypto_crc_poly", &crc->poly);
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+		if (res == NULL) {
+			dev_err(&pdev->dev, "No CRC DMA channel specified\n");
+			return -ENOENT;
+		}
+		crc->dma_ch = res->start;
+		crc->poly = (u32)pdev->dev.platform_data;
 	}
-	crc->dma_ch = res->start;
 
 	ret = request_dma(crc->dma_ch, dev_name(dev));
 	if (ret) {
@@ -635,7 +689,6 @@ static int bfin_crypto_crc_probe(struct platform_device *pdev)
 			* ((CRC_MAX_DMA_DESC + 1) << 1);
 
 	writel(0, &crc->regs->control);
-	crc->poly = (u32)pdev->dev.platform_data;
 	writel(crc->poly, &crc->regs->poly);
 
 	while (!(readl(&crc->regs->status) & LUTDONE) && (--timeout) > 0)
@@ -654,7 +707,7 @@ static int bfin_crypto_crc_probe(struct platform_device *pdev)
 		ret = crypto_register_ahash(&algs);
 		if (ret) {
 			dev_err(&pdev->dev,
-				"Can't register crypto ahash device\n");
+				"Cann't register crypto ahash device\n");
 			goto out_error_dma;
 		}
 	}
@@ -700,6 +753,7 @@ static struct platform_driver bfin_crypto_crc_driver = {
 	.resume    = bfin_crypto_crc_resume,
 	.driver    = {
 		.name  = DRIVER_NAME,
+		.of_match_table = of_match_ptr(bfin_crypto_of_match),
 	},
 };
 
diff --git a/drivers/crypto/bfin_crc.h b/drivers/crypto/bfin_crc.h
index 786ef746d109..75cef4dc85a1 100644
--- a/drivers/crypto/bfin_crc.h
+++ b/drivers/crypto/bfin_crc.h
@@ -55,6 +55,7 @@ struct crc_info {
 
 #include <linux/types.h>
 #include <linux/spinlock.h>
+#include <linux/miscdevice.h>
 
 struct crc_register {
 	u32 control;
-- 
2.11.0

